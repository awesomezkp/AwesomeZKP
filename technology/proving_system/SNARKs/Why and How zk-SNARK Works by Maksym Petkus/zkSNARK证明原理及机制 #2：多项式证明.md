*原文：<Why and How zk-SNARK Works 2: Proving Knowledge of a Polynomial>*

*翻译：Junwei*

> 这是一个系列文章。
>
> - [第 1 部分](zkSNARK证明原理及机制 #1：入门介绍和证明媒介.md)

我们从证明多项式知识的问题开始，然后逐步走向通用方法。在此过程中，我们将发现多项式的许多其他性质。

到目前为止的讨论都集中在证明的弱概念上，各方必须相互信任，因为还没有方法来执行协议的规则。例如，证明者不需要知道多项式，他可以使用任何其他方法来得出正确的结果。此外，如果验证者计算多项式的范围不大，比如$10$，证明者可以猜出一个数字，并且有不可忽视的概率被接受。我们必须解决协议的这种弱点，但首先知道多项式意味着什么？多项式可以表示为以下形式（其中$n$是多项式的次数）：

$$
c_nx^n+...+c_1x^1+c_0x^0
$$
如果有人说他知道一次多项式（即$c_1x^1 + c_0=0$），这意味着他真正知道的是系数$c₀$和 $c₁$。此外，系数可以为任何值，包括$0$。

假设证明者声称知道一个三次多项式，$x = 1 $和$x = 2$ 是所有可能解中的两个。满足条件的其中一个多项式是$x^3–3x^2+2x=0$。对于$x = 1：1 – 3 + 2 = 0$。对于$x = 2：8 – 12 + 4 = 0$。

让我们首先更进一步地剖析下多项式的解。

# 因式分解

代数基本定理指出，只要可解，任何多项式都可以因式分解为线性多项式（即表示直线的一次多项式）。因此，我们可以将任何有效的多项式表示为其因子的乘积：

$$
(x-a_-)(x-a_1)...(x-a_n)=0
$$
此外，如果这些因式中的任何一个为零，则整个方程为零，此后所有$a$都是唯一的解。事实上，我们的示例可以分解为如下的多项式：

$$
x^3-3x^2+2x=(x-0)(x-1)(x-2)
$$
解是（$x$的值）：0、1、2 ，你可以在多项式的任意形式上轻松检查这一点，但因式分解的形式上可以直观的看出所有解（也称为根）。

回到证明者声称他知道根为1和2的三次多项式，这意味着该多项式具有以下形式：

$$
(x-1)(x-2)·...
$$
换句话说，$(x – 1)$和$(x – 2)$是相关多项式的因式。因此，如果证明者想要证明他的多项式确实有这些根而不公开多项式本身，他需要证明他的多项式$p(x)$是这些因式$t(x) = (x-1)(x-2)$，称为目标多项式，和一些任意多项式$h(x)$（在我们的示例中等于$x – 0$）的乘积，即：

$$
p(x)=t(x)·h(x)
$$
换句话说，存在多项式$h(x)$与$t(x)$相乘等于$p(x)$，因此p(x)包含t(x)，因此$p(x)$具有$t(x)$的所有根，需要证明的事情。

找到$h(x)$的直接方法是通过除法

$$
h(x)=\frac{p(x)}{t(x)}
$$
如果证明者找不到这样的$h(x)$，则意味着$p(x)$没有因式$t(x)$，在这种情况下，多项式除法将有余数。在我们的示例中，如果我们将$p(x)=x^3 – 3x^2 + 2x$除以$t(x) = (x – 1)( x – 2)=x^2–3x+2：$

![img](/Users/junwei/Awesome-Scroll-CN/translation/Why and How zk-SNARK Works/img/2-1.webp)

> 注意：分母在左边，结果在右上方，余数在下方（多项式除法的解释和例子可以在[[Pik14](https://medium.com/@imolfar/why-and-how-zk-snark-works-2-proving-knowledge-of-a-polynomial-f817760e2805#e105)]中找到）。

我们得到了没有余数的结果$h(x)=x$。

> 注意：简单起见，以后我们将使用多项式的字母变量来表示其计算结果，例如，$p=p(r)$

使用我们的多项式身份检查协议，我们可以比较多项式$p(x)$和$t(x)⋅h(x)$

- 验证者采样一个随机值$r$，计算$t=t(r)$并将r给证明者
- 验证者计算$h(x) = p(x) / t(x) $并计算$p(r)$和$h(r)$；并将结果值$p, h$提供给验证者
- 验证者随后检查$p=t⋅h$是否相等，如果是，则这些多项式相等，这意味着$p(x)$具有$t(x)$的因式。

实际运用中，我们对示例中的多项式执行此协议：

- 验证者抽取一个随机值$23$，计算出$t=t(23)=(23–1)(23–2)= 62$并将$23$交给证明者
- 证明者计算$h(x)= p(x)/t(x)= x$，求出$p=p(23)=10626$和$h=h(23)=23$，并将$p,h$提供给验证者
- 验证者随后检查$p=t⋅h: 10626=462⋅23$，是正确的，因此证明了该声明

相反，如果证明者使用不同的$p^{′}(x)$，它不包含必要的因式，例如$p^{′}(x)=2x^3–3x^2+2x$，那么：

![img](2-2.webp)

> 注意：虽然笔者的主要目标是通俗易懂，包括使用的数学符号集，但在后续章节中省略无处不在的符号：'是有问题的。它的基本作用是表示原始变量或函数的某种变换或推导，例如，如果我们想将v乘以2并将其分配给一个单独的变量，我们可以使用符号：$v^{′}= 2 ⋅ v$ 。

我们将得到$2x+3$，余数为$7x –6$，即：$p(x) = t(x) × (2x+3) + 7x – 6$。这意味着证明者必须通过将余数除以$t(x)$来计算：

$$
h(x)=2x+3+\frac{7x-6}{t(x)}
$$
因此，由于验证者对$x$的随机选择，余数$7x–6$的计算结果被$t(x)$计算结果整除的概率很低（但仍然不可忽视），随后如果验证者将另外检查$p$和$h$必须是整数，这样的证明将被拒绝。然而，检查要求多项式系数也为整数，这对协议造成了重大限制。

这就是引入加密原语的原因，它使这种划分成为不可能，即使原始评估恰好是可分的。

**Remark 3.1** *现在我们可以在不知道多项式本身的情况下检查多项式的特定属性 ，因此这已经为我们提供了某种形式的零知识和简洁性。尽管如此，这样构建存在多个问题：*

- *证明者可能根本不知道所要求的多项式 $p(x)$ 。他可以计算 $t = t ( r ) $，选择一个随机数h并设置$p=t⋅h$，这将被验证者接受为有效，因为等式成立。*
- *因为证明者知道随机点$x = r$，他可以构造任何在r处有一个交点且具有$t(r)⋅h(r)$的多项式。*
- *在原始声明中，证明者声称知道特定次数的多项式，在当前协议中没有次数的强制限制。 因此，证明者可以通过使用也满足因式检查的更高阶多项式来作弊。*

我们将在如下部分解决所有这些问题。

# 模糊多项式求值(Obscure Evaluation)

Remark 3.1 的前两个问题是可能的，因为值以原始形式呈现，证明者是知道$r$和$t(r)$的。理想情况下如果这些值作为黑盒给出，这样人们就无法对协议进行调整，但仍然能够对这些模糊值进行计算操作。类似于哈希函数在计算时很难返回原始输入。

## 同态加密

这正是同态加密的设计目的。也就是说，它允许加密一个值并能够对这种加密应用算术运算。实现同态加密的方式有多种，我们简单介绍一种。

一般的想法是我们选择一个基数（基数需要具有某些属性）自然数 $g$（比如 $5$）并加密一个值，我们将该值作为基数的指数求幂。例如，如果我们要加密数字 $3$：

$$
5^3=125
$$
其中125是3的加密值。如果我们想将这个加密数字乘以 $2$，我们将加密值的指数变为$2$：

$$
125^2=15625={(5^3)}^2=5^{2\times3}=5^6
$$
我们能够将未知值乘以2并将其加密。我们还可以通过乘法将两个加密值相加，例如3+2：

$$
5^3·5^2=5^{3+2}=5^5=3125
$$
同样，我们可以通过除法来减去加密数字，例如，5 – 3：

$$
\frac{5^5}{5^2}=5^{5-2}=5^3=3125
$$
但是，由于基数5是公开的，所以很容易逆运算得到秘密值，将加密值除以5直到结果为1，计算步数就是秘密值。

## 模运算

这就是模运算算法发挥作用的地方。模运算的思想如下：我们声明我们只选择前$n$个自然数，即$0、1 、…、n – 1$ 来处理，而不是有一个无限的数字集，如果任何给定的整数没有落在这个范围内，我们将其“包”起来。例如，让我们选择前六个数字。为了方便解释，考虑一个有六个单位相等的刻度的圆圈；这是我们的范围（通常称为有限域）。

![img](2-3.webp)

现在让我们看看数字8会落在哪里。打个比方，我们可以把它想象成一根绳子，它的长度是8个单位：

![img](2-4.webp)

如果我们把绳子系在圆圈的开头

![img](2-5.webp)

并开始将绳子缠绕在它周围，旋转一圈后我们还剩下一部分绳子：

![img](2-6.webp)

因此，如果我们继续该过程，绳索将在第 2 个刻度处结束。

![img](2-7.webp)

这就是模运算的结果。无论绳子有多长，它总是会停在圆圈的一个刻度处。因此，模运算会将其保持在特定范围内（在本例中为 0 到 5）。15 个单位的绳子将在 3 处停止，即 $6 + 6 + 3$（两个完整的圆圈，剩余 3 个单位）。负数的工作方式相同，唯一的区别是我们将其换向相反的方向，对于–8，结果将为 4。

而且，我们可以进行算术运算，结果总是在n个数的范围内。我们现在将使用符号“mod n ”来表示数字的范围。例如：

$$
3\times2=3\ mod\ 6\\
5+2=1\ mod\ 6
$$
此外，最重要的特性是操作的顺序无关紧要，例如，我们可以先执行所有操作然后进行模运算或在每个操作之后进行模运算。例如$ (2 × 4 – 1) × 3 = 3 (mod 6)$ 等同于：

$$
2\times4=2\ (mod\ 6)\\
2-1=1\ (mod\ 6)\\
1\times3=3\ (mod\ 6)
$$
那么到底为什么会有帮助呢？事实证明，如果我们使用模运算，得到一个运算结果，不可能返回到原始数字，因为许多不同的组合将有相同的运算结果：

$$
5\times4=2\ (mod\ 6)\\
4\times2=2\ (mod\ 6)\\
2\times1=2\ (mod\ 6)\\
...
$$
如果没有模运算，结果的大小会透露其解的线索。现在这条信息被隐藏起来，同时保留了通用算术的属性。

## 强同态加密

如果我们回到同态加密并使用模运算，例如模 7，我们将得到：

$$
5^1=5\ (mod\ 7)\\
5^2=4\ (mod\ 7)\\
5^3=6\ (mod\ 7)
$$
不同的指数将有相同的结果：

$$
5^5=3\ (mod\ 7)\\
5^11=3\ (mod\ 7)\\
5^{17}=3\ (mod\ 7)
$$
这是很难找到指数的原因。事实上，如果模足够大，找到指数是几乎不可能的，现代密码学的很大一部分都是基于该问题的“难度”。

该方案的所有同态性质在模块化下都得以保留：

$$
encryption:\ 5^3=6\ (mod\ 7)\\
multiplication:\ 6^2={(5^3)}^2=5^6=1\ (mod\ 7)\\
addition:\ 5^3·5^2=5^5=3\ (mod\ 7)
$$

> 注意：模块化划分有点复杂，超出本文范围

让我们明确说明加密功能：

$$
E(v)=g^v\ (mod\ n)
$$
其中$v$是我们要加密的值。

**备注 3.2** *这种同态加密方案存在局限性，虽然我们可以将加密值乘以未加密值，但不能将两个加密值相乘（和相除），也不能对加密值求幂。虽然第一印象看很糟糕 ，但这些属性将成为zkSNARK的基石。这些限制在“加密值的乘法”部分进行了说明。*

## 加密多项式

有了这样的工具，我们现在可以用加密随机值x来计算多项式，并相应地修改零知识协议。

让我们看看如何计算多项式$p(x)=x^3 – 3x^2 + 2x$。正如我们之前构建的那样，知道多项式就是知道它的系数，在这里就是是：$1、–3、2$。我们必须得到加密值$x$从1到3次方的幂值：$E(x) , E(x^2) , E(x^3)$，因为不能直接对$E(x)$做平方/立方得到$E(x^2) , E(x^3)$，这样我们就可以计算加密多项式如下：

$$
{E(x^3)}^1·{E(x^2)}^{-3}·{E(x)}^2=\\
{(g^{x^3})}^1·{(g^{x^2})}^{-3}·{(g^{x^1})}^2=\\
g^{1x^3}·g^{-3x^2}·g^{2x}=\\
g^{x^3-3x^2+2x}
$$
这样运算的结果是，我们在一些未知的$x$处对多项式进行了加密计算。这是一个非常强大的机制，并且由于同态属性，相同多项式的加密求值在加密空间中总是相同的。

我们现在可以更新之前版本的协议，对于$d$次多项式：

- 验证者
	- 取随机数 $s $
	- 计算随机数$s $各阶数加密后的值 $E(s^i)=g^{s^i}, i\in{\{0,1,2,...,d\}} $，并提供给证明者
	- 计算未加密的目标多项式: $t(s) $
- 证明者
	- 计算多项式 $h(x)=\frac{p(x)}{t(x)}$
	- 根据加密值 $g^{s^0},g^{s^1},...,g^{s^d} $和系数$c_0,c_1,...,c_n $，进行多项式求值 $E(p(s))=g^{p(x)}=g^{c_dx^d+…+c_0x^0}=(g^{x^d})^{c_d}·...·(g^{x^0})^{c_0} $， 同理计算$E(h(s))=g^{h(s)} $ 
	- 提供计算结果$g^p $和$g^h $给验证者
- 验证者
	- 对于验证者而言，最后一步是检查$p=t(s)·h: g^p={(g^h)}^{t(s)}  $ => $g^p=g^{t(s)·h} $

> 注意：因为证明者对 $s$ 一无所知，所以很难伪造仍然匹配的多项式求值。

虽然在这样的协议中，证明者的是有限的，但他仍然可以使用任何其他方式来伪造证明，而无需实际使用提供的$s$的各阶加密值，例如，如果证明者声称仅使用3次幂$s^3$和1次幂$s^1$，在当前协议中无法检验。

# 约束多项式

多项式的知识是其系数$c₀、c₁ 、…、cᵢ$的知识，我们在协议中“分配”这些系数的方式与随机数s的各阶幂加密值相乘。我们已经在选择s的各阶幂的加密值时对证明者进行了约束，但是没有强制这类约束，例如，证明者可以使用任何可能的方法找到任意值$z_p$和$z_h$满足等式

$$
z_p=(z_h)^{t(s)}
$$
并将它们提供给验证者而不是$g^p$和$g^h$。这就是为什么验证者需要验证证明者只使用了$s$的各阶幂加密值而没有其他任何东西。

让我们考虑一个有一个变量和一个系数的一次多项式的基本例子$f ( x ) =c⋅x$和对应的$s$的加密值$E ( s ) = g^s$。我们正在寻找的是确保只有$s$ 的加密值即$g^s$，与某个任意的系数$c$同态“相乘”而不是其他任何东西。因此，结果肯定是如下的形式（对于任意系数$c$）：

$$
(g^s)^c
$$
一种方法是要求对另一个位移后的加密值与原始值一起执行相同的操作，作为算术模拟的“校验和(checksum)”，确保结果是原始值的幂。

更准确地说，这是通过[Dam91]中引入的Knowledge-of-Exponent Assumption(或KEA)实现的（注意$a$和$\alpha$(alpha)之间的区别）：

1. Alice 有一个值$a$，她希望 Bob 对任何幂取幂（其中a是使用的有限域群的生成元），唯一的要求是$a$只可以进行指数运算，不能进行别的操作。为了确保这一点，Alice
	1. 选择了随机数α
	2. 计算$a'=a^{\alpha} (mod\ n) $
	3. 将元组(a, a')提供了Bob，要求对每个值都进行任意指数运算并返回元组(b,b')，并保持"α位移"，即$b'=b^{\alpha}(mod\ n) $
2. 因为Bob无法从元组$(a, a ')$ 中提取出$α$ ，除非通过不可行的暴力破解，因此可以预见的是，Bob要想生成有效响应的唯一方法是通过以下过程：
	1. 选择某个常数c
	2. 计算$b=a^{c}\ (mod\ n) $和$b'=(a')^{c}\ (mod\ n) $
	3. 响应元组(b,b')
3. 有了响应和$α$，Alice检查等式：
	1. $b'=b^{\alpha} $ 
	2. ${(a^c)}^{\alpha} = {(a')}^c $
	3. $a^{c·\alpha} = {(a^{\alpha})}^c $

结论：

- Bob对元组的两个值应用了相同的指数（即$c$ ）
- Bob 只能用原来 Alice 的元组来维持$α$位移的关系
- Bob知道应用的指数$c$，因为产生有效 $( b,b^′) $的唯一方法是使用相同的指数
- Alice无法知道$c$的原因与Bob无法知道$α$的原因相同。

*尽管$c$已加密，但其值的范围可能不足以保证零知识的特性，这将在“零知识”部分中解决。*

最终，协议向Alice提供了一个证明，即Bob确实用他已知的某个值对$a$求幂，并且他不可能进行任何其他操作，例如乘法、加法，因为这会消除$α$位移的关系。

在同态加密的背景下中，求幂是加密值的乘法。我们可以在简单的单系数多项式$f(x) = c⋅x$的情况下应用相同的构造：

- 验证者选择随机数$s,α$并为$x = s$的一阶幂及其“位移”进行求值：

$$
(g^s,g^{}\alpha·s)
$$

- 证明者应用系数$c$：

$$
((g^s)^c,(g^{\alpha·s})^c)=(g^{c·s},g^{\alpha·c·s})
$$

- 验证者检验：

$$
{(g^{c·s})}^{\alpha}=g^{\alpha·c·s}
$$

这种构建限制了证明者只能使用提供的加密值s，因此证明者只能将系数c分配给验证者提供的多项式。我们现在可以将这种单项多项式（单项式）方法扩展为多项式，因为每个项的系数分配是单独计算的，然后同态“相加”在一起（这种方法由Jens Groth在[[Gro10](https://medium.com/@imolfar/why-and-how-zk-snark-works-2-proving-knowledge-of-a-polynomial-f817760e2805#3068)]中引入）。因此，如果证明者得到s的加密幂值及其位移值，他就可以对原始多项式和位移多项式进行求值，并进行相同的检验。特别地，对于d次多项式而言：

- 验证者计算随机数$s $各阶幂加密后的值 $E(s^i)=g^{s^i}, i\in{\{0,1,2,...,d\}} $和相应的位移项 $E(s^{\alpha i})=g^{\alpha s^i}, i\in{\{0,1,2,...,d\}} $
- 证明者
	- 根据各阶幂的加密值计算加密多项式$g^{p(x)}=g^{c_dx^d+…+c_0x^0}=(g^{x^d})^{c_d}·...·(g^{x^0})^{c_0} $
	- 根据位移项计算加密的“位移”多项式 $g^{\alpha p(x)}=g^{c_d\alpha x^d+…+c_0\alpha x^0}=(g^{\alpha x^d})^{c_d}·...·(g^{\alpha x^0})^{c_0} $
	- 将结果 $g^p,g^{p'} $提交给验证者
- 验证者验证: ${(g^p)}^{\alpha}=g^{p'} $

对于我们之前的示例多项式$p(x) = x^3 –3x^2+ 2x$这将是：

- 验证者提供 $E(s^3),E(s^2),E(s) $和相应的位移项$E(\alpha s^3),E(\alpha s^2),E(\alpha s^1) $
- 证明者计算

$$
g^p=g^{p(s)}=(g^{s^3})^1·(g^{s^2})^{-3}·(g^{s})^2=g^{s^3}·g^{-3s^2}·g^{2s}=g^{s^3-3s^2+2s}\\
g^{p^{'}}=g^{\alpha p(s)}=(g^{\alpha s^3})^1·(g^{\alpha s^2})^{-3}·(g^{\alpha s})^2=g^{\alpha s^3}·g^{-3\alpha s^2}·g^{2\alpha s}=g^{\alpha (s^3-3s^2+2s)}
$$

- 验证者检验$(g^p)^{\alpha}=g^{p^{'}}$

$$
(g^{s^3-3s^2+2s})^{\alpha}=g^{\alpha(s^3-3s^2+2s)}\\
g^{\alpha(s^3-3s^2+2s)}=g^{\alpha(s^3-3s^2+2s)}
$$

现在我们可以确定证明者除了验证者提供的多项式之外没有使用任何其他东西，因为没有其他方法可以保留$α$位移关系。此外，如果验证者想要确保排除证明者多项式中$s$的某些幂，例如$j$，他可以不提供加密值及其移位：

$$
g^{s^j},g^{\alpha s^j}
$$
与最开始时相比，我们现在有了一个健壮的协议。然而目前零知识特性仍然存在一个明显的缺点：虽然理论上多项式系数$cᵢ$值的范围可以很大，实际上它可能非常有限（在前面的例子中是 6），这意味着验证者可以暴力破解有限范围内的系数组合，直到结果满足证明者的答案。例如，如果我们考虑每个系数值的范围是100，则二次多项式将总共有100万个不同的组合，考虑到暴力破解只需要不到一百万次。更重要的是，安全的协议即使在只有一个系数且其值为1的情况下，也应该是安全的。

# 零知识

因为验证者只能从证明者发送的数据中提取关于未知多项式$p(x)$的知识，所以让我们看一下那些提供的值（证明）：

$$
g^p,g^{p^{''}},g^h
$$
他们参与如下检验：

$$
g^p=(g^h)^{t(s)}\\
(g^p)^{\alpha}=g^{p^{'}}
$$
问题是我们如何修改证明，使检验仍然有效，但无法提取任何知识？可以从上一节中得出答案：我们可以将这些值“位移”一些随机值$δ$ (delta)，例如，$(g^p)^{\delta}$。现在，为了提取知识，首先需要找到$δ$ ，这是不可行的。此外，这种随机化在统计上无法区分。

为了保持等式关系，让我们来看验证者的检验。证明者所提供的值在等式的两边。因此，如果我们用将它们每一个都采取相同的$δ$“位移”，则方程肯定保持平衡。

具体来说，证明者对选取随机数$δ$并用它对其证明值求幂

$$
(g^{p(s)})^{\delta},(g^{h(s)})^{\delta},(g^{\alpha p(s)})^{\delta} 
$$
并提供给验证者进行验证：

$$
(g^p)^{\delta}={((g^h)^{\delta})}^{t(s)}\\
((g^p)^{\delta})^{\alpha}=(g^{p^{'}})^{\delta}
$$
合并后我们可以观察到检验仍然有效：

$$
g^{\delta·p}=g^{\delta·t(s)·h}\\
g^{\delta·\alpha p}=g^{\delta·p^{'}}\\
$$

> *注意：构建过程中加入零知识很容易，这通常被称为“免费”的零知识。*

# 参考资料

1. [Pik14] — Scott Pike. Dividing by a Polynomial. 2014. url: http://www.mesacc.edu/~scotz47781/mat120/notes/divide_poly/long_division/long_division.html(visited on 2018–05–01)
2. [Dam91] — Ivan Damgård. “Towards practical public key systems secure against chosen ciphertext attacks”. In: Annual International Cryptology Conference. Springer. 1991, pp. 445–456.
3. [Gro10] — Jens Groth. “Short pairing-based non-interactive zero-knowledge arguments”. In: International Conference on the Theory and Application of Cryptology and Information Security. Springer. 2010, pp. 321–340.