# zkApps的工作原理

zkApps 是使用 Mina zkApp CLI 用 TypeScript 编写的。在接下来的[如何编写 zkApp](https://docs.minaprotocol.com/zkapps/how-to-write-a-zkapp)部分，我们将详细介绍如何编写您的第一个 zkApp。现在，我们将讨论 zkApps 是如何工作的。

“zkApp”由两部分组成：1）智能合约和 2）供用户与之交互的 UI（用户界面）。

![img](https://docs.minaprotocol.com/img/3_zkApps_Structure.jpg)zkApps 由两部分组成：1) 智能合约和 2) 供用户与之交互的 UI（用户界面）。

注意：

> 我们使用术语**“智能合约”**来指代使用 SnarkyJS（将在下面介绍）编写的代码。
>
> 我们使用术语**“zkApp”**来指代 UI + 智能合约。

## 基于零知识证明的智能合约

因为 zkApps 基于**零知识证明 (zk-SNARKs)**，zkApp 开发人员编写了所谓的**“电路”**，这是在构建过程中派生出**证明者函数**和对应的**验证者函数的方法。**

**证明者函数**是执行智能合约的自定义逻辑的函数。

**证明者函数**作为 zkApp 的一部分在用户的 Web 浏览器中运行。当与 zkApp 的 UI 交互时，用户将输入所需的任何数据（例如“以 y 价格购买 ABC”）作为证明函数的输入，然后将生成零知识证明。

![img](https://docs.minaprotocol.com/img/4_zkApps_Prover_Function.jpg)证明者函数是执行智能合约的自定义逻辑的函数。

**隐私输入**和**公开输入**都表示在用户的网络浏览器中运行时必须提供给证明函数的数据。

在那之后不再需要**隐私输入。**但是当它在 Mina 网络上运行时，还必须向验证函数（马上将会介绍）提供**公开输入，这样将永远不会使用你希望保持隐私的数据。**

**验证者函数**是验证零知识证明是否成功通过证明者函数中定义的所有约束的函数。*无论证明者函数如何复杂，*它*总是*可以快速有效地运行。

在 Mina 网络中，Mina 作为验证者，运行验证者功能。我们很快将描述它是如何工作的。

![img](https://docs.minaprotocol.com/img/5_zkApps_Verifier_Function.jpg)验证者函数是验证零知识证明是否成功通过证明者函数中定义的所有约束的函数。

## 证明者函数和验证密钥

当 zkApp 开发人员编写他们的智能合约并运行`npm run build`时，构建过程会生成`smart_contract.js`。由此，你可以运行你的证明者函数或生成验证密钥，你将需要分别运行或部署您的智能合约。

**证明者函数**在用户的网络浏览器中运行。

**验证密钥**存在于给定 zkApp 帐户的链上，Mina 网络使用它来验证零知识证明是否满足证明者中定义的所有约束。需要验证密钥才能创建 zkApp 帐户。我们将在下面对此进行更多阐述。

接下来的两节将更详细地介绍在部署 zkApp 时以及用户与 zkApp 交互时如何使用证明者和验证者函数。

## 部署智能合约

![显示 Mina zkApp 智能合约部署的图表](https://docs.minaprotocol.com/img/6_zkApps_DeploySmartContract.jpg)



要将智能合约部署到 Mina 网络，开发人员使用 Mina zkApp CLI。部署过程将包含验证密钥的交易发送到 Mina 区块链上的地址。

当 Mina 地址包含验证密钥时，它充当**zkApp 帐户**。普通 Mina 账户可以接收任何交易，而 zkApp 账户只能成功接收包含满足验证者函数的证明的交易。任何未通过验证者函数的交易都将被 Mina 网络拒绝。

信息：

> 当你部署到一个新的 Mina 地址时，Mina 协议将收取 1 MINA 的账户创建费用。这与 zkapps 无关，旨在帮助防止女巫攻击或DDoS攻击。

## 部署 zkApp UI

![img](https://docs.minaprotocol.com/img/7_zkApps_DeploySmartContract.jpg)

开发人员通常构建一个 UI 来允许用户与智能合约进行交互。

通常，这会部署到开发人员选择的主机上的静态网站。我们推荐使用提供全球 CDN 的网络主机，以确保最佳用户体验。

您的网站需要包含构建智能合约时生成的文件`smart_contract.js`。在[如何编写 zkApp](如何编写 zkApp.md)页面，我们将进行更详细的介绍。

![img](https://docs.minaprotocol.com/img/8_zkApps_DeploySmartContract.jpg)

## 用户如何与zkApp交互

信息：

> 要使用 zkApp，用户必须[为 Google Chrome 安装 Auro 钱包](https://www.aurowallet.com/)。我们预计未来其他钱包会增加对 zkapps 的支持。

Auro 是目前唯一支持 zkApp 交易的钱包。但是，我们计划在未来将对 zkApps 的支持扩展到其他类型的钱包（例如移动钱包和桌面钱包）。

将 zkApp 部署到主机（例如 mycoolzkapp.com）后，用户可以与其交互：

1. 用户访问 mycoolzkapp.com。
2. 用户与 zkApp 交互并根据需要输入任何数据。（例如，如果这是一个自动做市商 (AMM)，用户可能会指定“以 y 价格购买 x 数量的 ABC”。）
3. zkApp 中的证明者函数现在将根据用户输入的数据在本地生成零知识证明。这些数据可以是隐私的（区块链永远不会看到）或公开的（将存储在链上或链下），具体取决于给定用例下开发人员指定的需要。此外，将生成一个由该交易创建的状态更新列表，并与该证明相关联。（我们将这些称为“事件”，我们将在下面进一步详细介绍它们。）
4. 用户在 zkApp UI 中点击“提交上链”，他们的钱包（例如浏览器插件钱包）将提示他们确认发送交易。钱包签署包含证明和需要更新的相关状态的交易并将其发送到 Mina 区块链。
5. 当 Mina 网络收到此交易时，它将验证证明是否成功通过 zkApp 帐户上列出的验证者函数。如果网络接受此交易，则表明此证明和请求的状态更新是有效的，因此可以更新 zkApp 的状态。

由于用户的交互发生在他们的 Web 浏览器*本地*（在客户端使用 JavaScript），因此可以维护用户的隐私。

## 链上的状态如何更新

你可能想知道 zkApp 帐户上的状态是如何在链上更新的。为了简单起见，我们之前忽略了这个细节。

当证明者函数在网络浏览器中运行时，智能合约会输出一个证明和一些我们称之为“事件”的相关数据。当向 zkApp 地址发送交易时，这是作为交易的一部分发送的。这些事件是明文描述（JSON 格式），描述了如何更新 zkApp 帐户的状态。

这些事件的完整性通过将这些事件的哈希作为公开输入传递给智能合约来确保。它们必须存在且未经修改才能使在 Mina 上运行的验证函数成功通过。通过这种方式，Mina 网络可以确认证明和描述如何更新 zkApp 帐户状态的相关事件的完整性。

## ZkApp状态

Mina 上存在两种不同类型的状态：链上状态和链下状态。

链上状态描述了存在于 Mina 区块链上的状态。链下状态描述了存储在其他地方的状态——例如[IPFS](https://ipfs.io/)等。

## 链上状态

每个zkApp账号提供8个字段，每个字段包含32字节的任意存储。只要符合所提供的大小限制，你就可以将任何东西存放在这里。

如果你预计状态会比这个大，或者如果你的 zkApp 状态会随着每个用户累加，那么你会想要使用链下状态。

## 链下状态

信息：

> 即将支持链下状态。

对于更大的数据，你可能需要考虑将[ 默克尔树](https://en.wikipedia.org/wiki/Merkle_tree)（或类似数据结构）的根存储在 zkApp 的链上存储中，该存储引用存储在你选择的其他位置中的额外链下状态，例如[IPFS](https://ipfs.io/)。

当 zkApp 在用户的 Web 浏览器中运行时，它可能会将状态插入外部存储，例如 IPFS。当交易被发送到 Mina 网络时，如果它接受这个 zkApp 交易（即这个证明和状态是有效的，所以允许更新），那么 zkApp 交易将更新存储在链上的默克尔树的根。

![img](https://docs.minaprotocol.com/img/9_zkApps_Off-Chain_State.jpg)

## 继续前进

在下一页，我们将深入探讨[如何编写 zkApp](如何编写zkApp.md)
