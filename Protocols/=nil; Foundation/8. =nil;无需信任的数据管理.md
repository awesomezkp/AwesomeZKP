## 这是关于什么的？

任何类型的数据管理（无论是 OLAP 还是类似 OLTP 的负载）都需要对数据有一定的访问权限。关键数据管理需要手头有数据。在完全控制下的受信任环境中的完整副本。但是，如果不存在这种可能性（例如，由于成本原因）怎么办？通常的解决方案是——信任数据提供者。就像他们对 AWS 或 Infura 所做的一样。猜猜这会导致什么？给你：[https](https://www.coindesk.com/policy/2022/03/03/metamask-infura-block-certain-areas-amid-crypto-sanctions-fury/) ://www.coindesk.com/policy/2022/03/03/metamask-infura-block-certain-areas-amid-crypto-sanctions-fury/ 。

现在，如果需要在其他某个数据库（也称为所谓的“桥梁”）中放置和使用这样一个受信任的数据源怎么办？好吧，这里不幸发生了什么： [https](https://www.coindesk.com/business/2022/08/02/nomad-hacked-45m-stolen-so-far-report/) : //www.coindesk.com/business/2022/08/02/nomad-hacked-45m-stolen-so-far-report/，https: [//www.theverge.com/ 2022/2/3/22916111/wormhole-hack-github-error-325-million-theft-ethereum-solana](https://www.theverge.com/2022/2/3/22916111/wormhole-hack-github-error-325-million-theft-ethereum-solana)。

这就是这篇文章 =nil; 的无信任数据管理解决方案的原因，它应该通过基于 =nil;的状态和查询证明来解决这些问题。'DROP DATABASE 通过将三个主要用例放在一起：

1.  **无信任（非优化）数据检索和插入。**通过简单的查询语言（基于 SQL 或 JS 的语言）从不同的数据库（容错的完整副本，包括比特币或以太坊或其他任何东西）检索和插入数据，而无需因为 SNARK 数据正确性证明而信任数据提供者.
2.  **无信任桥接。**使用从协议中检索的数据和 SNARK 正确性证明将来自不同协议数据库的数据相互放置。
3.  **可插拔的无信任缩放。**使用从协议中检索的数据和 SNARK 正确性证明，通过部署多个独立的特定于应用程序的集群来增加特定协议的吞吐量。

## =无；'删除数据库 * ?

[=无；'DROP DATABASE *](https://blog.nil.foundation/2021/12/01/database-management-system.html)是=nil开发的数据库管理系统；基金会的目的是使用单个软件处理可公开复制的容错完整副本数据库（例如比特币或以太坊）——就像使用适当的 DBMS（例如 MySQL 或 PostgreSQL）一样。这允许：

1.  为此类数据库引入统一的读写查询语言
2.  通过在基于软件的单个集群或独立部署中管理多个数据库来降低部署和维护成本。
3.  通过使用良好的旧 DBMS 特定技术来提高部署的持久性。

关于=nil的更多详细信息；'DROP DATABASE * 可以在相关博文中找到：[https](https://blog.nil.foundation/2021/12/01/database-management-system.html) ://blog.nil.foundation/2021/12/01/database-management-system.html 。

## 但它与去信任的数据管理协议有什么关系呢？

[=无；'DROP DATABASE *](https://blog.nil.foundation/2021/12/01/database-management-system.html)消除了数据可访问性和维护成本问题，就好像它们从未存在过一样。这是通过使用同一软件管理多个可公开复制的容错完整副本数据库并提供读/写查询语言来完成的，所有数据库都支持复制协议。典型的 DBMS 功能。另一个典型的现代 DBMS 特征是集群化。同样的事情 =零；'DROP DATABASE * 也提供。

让任何公共数据库（或者协议，如果你真的喜欢这个名字）数据可以用相同的语言管理，自然会产生在这样的解决方案之上启动一个可公开复制的集群的愿望，看看用它可以实现什么。这导致除了第三方协议之外，还需要引入一些能够提供此类数据可访问性的本机复制协议。

与第三方复制协议一样，本机复制协议应符合复制协议适配器接口。它还必须能够为用户提供适当的吞吐量，以便从许多不同的数据库中检索数据成为可能。

## 好的。它会是什么？

传统的 DBMS 提供的集群化是基于网络通信的，设计脆弱，有利于复制/分区性能，并且应该在受信任的环境（例如[Raft](https://en.wikipedia.org/wiki/Raft_(algorithm)) 或[etcd](https://etcd.io/)类似的环境）中工作。[如果在此类共识算法系列（例如拜占庭 Paxos](https://en.wikipedia.org/wiki/Paxos_(computer_science)#Byzantine_Paxos) ）中实现了任何容错，它再次对网络通信环境非常敏感，并且应该以最佳方式处理次要参与者的不当行为。

不那么脆弱的集群化通常是通过数据共识来实现的，让网络只处理数据传输。比特币、以太坊和其他人使用这种集群化来维护一致性极低但具有适当可用性的数据库集群。

那么，关于=nil;的集群化选项，我们最终会得到什么？ 'DROP DATABASE * -based 集群（为了适当的架构泛化）？

1.  基于网络的集群化：
    1.  分区（实现不同，我们必须找出自己的实现）。用于将集群的节点状态拆分到多个服务器。因此，这仅适用于受信任的环境设置。
    2.  复制（Raft、Paxos、etcd 等）。同样，可信环境设置中的低规模集群。
2.  基于数据的集群化：
    1.  复制（字面上牺牲一致性以支持可访问性）。基于网格的网络，嘈杂如地狱（就网络而言），但可公开访问。此选项似乎也是利用总数据可访问性的最佳方式。

但！实际可公开复制的数据库集群复制协议设计将取决于应用程序的目的。

## 好吧。那么让我们选择一个目的。请提供有用的东西。

当然。

最明显的事情是利用其他人没有的东西——_完全的数据可访问性_。例如，为每个协议提供每个其他协议的数据。或者为最终用户应用程序提供任何数据库的入口点。

关于如何设置它有几个选项：

1.  设置托管 DBMS 托管，其中将包含所有集群的数据（又名 Infura with SQL）。
    
    猜猜，这有什么问题？考虑到应该由唯一组织管理的广泛基础设施，很难扩展（尤其是现在）——有些=零； 基金会相关的。我们也已经拥有亚马逊、谷歌云、Azure 等，它们也不是可靠的数据源——我们不应该相信数据提供者会诚实地提供正确的数据。
    
    对我来说似乎不是一个选择。
    
2.  建立一个可公开复制的数据库集群，这样任何一方都可以在任何时候无需许可地加入——这也将同时加强数据提供的基础设施。
    

我喜欢这个选项，因为它可以更好地扩展，并且仍然保留了类似数据提供程序的托管 DBMS 解决方案的性能。所需要的只是让多个参与者启用必要的协议复制适配器（例如，同时在单个节点中使用比特币、以太坊和 Polkadot）。

但是，一个提供数据的可公开复制的数据库集群将需要：

1.  吞吐量限制机制，以避免向数据库内容发送垃圾邮件
2.  在引入这种吞吐量限制机制的情况下，这将需要包含这种速率限制状态描述的整体数据库一致性索引由所有数据库集群成员以容错复制启用的完全类似副本的方式处理。

如果我们选择选项 2，提供数据的可公开复制的数据库集群将需要机制来处理其不信任的性质，即节流。具体来说，我们将需要一种吞吐量限制机制来避免向数据库内容发送垃圾邮件。这将要求所有数据库集群参与者维护全局吞吐量索引的完整副本。

如果节流组件与复制协议适配器一起实施，那么任何愿意的一方都可以加入可公开复制的数据库集群。这将允许他们将第三方数据同步到 =nil; 'DROP DATABASE * **instance** ，然后让他们通过统一的查询语言（例如，基于 SQL 的语言或一些命令式，例如，基于JS的一个）。

## 但这会导致提供数据的中继器。有什么办法让它变得不可信？

现在我们正在谈论。你是对的，最好不要相信中继者。

为什么？强迫数据消费者信任中继器显然不是最佳选择，因为他们对提供虚假数据的恶意中继器的唯一保护是薄弱的博弈论保证。

因此，我们需要消除信任数据提供者的必要性。

有几种方法可以做到这一点：

1.  最明显的方法是加强那些博弈论假设，追溯惩罚那些试图提供虚假数据的协议成员，使用户能够提交关于他们的投诉。类似于那些“图表”或“袖珍网络”的东西。但！这导致了所谓的“乐观安全”，当一个普通的愚蠢的海量数据欺诈被阻止时（这更像是一种流氓行为而不是欺诈），但没有什么能阻止攻击者等待一个非常特殊的交易并泄露假数据恰好在特定交易进入的那一刻。
    
    > 顺便一提。那有什么意思？“乐观安全”。“很可能它是安全的”？“很可能什么都不会被偷？”
    > 
    > 哦哦，等一下，我有一个更好的。用典型的凯伦 (Karen) 的声音朗读这篇文章。
    > 
    > **“当你的资金因为‘乐观安全’而被盗时——请提出投诉。协议的秘书（想象一下这样的人存在）会考虑它并通过美国邮政向您发送关于做出决定的书面通知”。感谢您使用我们的“乐观安全”协议服务。**
    > 
    > 不，谢谢。
    
2.  更好的方法是完全不依赖博弈论保证。具体来说，这将要求执行某些查询的用户可以确定返回数据的来源，而不必自己验证检索过程（例如，通过自己重复计算）。
    
    我们该怎么做？让我们使用我们拥有的任何东西。我们要处理的是[=nil；'删除数据库*](https://blog.nil.foundation/2021/12/01/database-management-system.html)。典型的 DBMS 可以处理的是查询引擎/规划器。
    
    所以！为查询规划器生成 SNARK 证明，结果证明查询返回的实际数据是从存储在 [=nil 中的数据库（例如 Solana 或 Ethereum）状态中正确提取的；'删除数据库*](https://blog.nil.foundation/2021/12/01/database-management-system.html)。
    
    > 实际上，让我们考虑一个由 a =nil;返回的下表的示例证明；'DROP DATABASE * SQL 查询 Solana 的状态。
    > 
    > 帐户 ：`STRING`
    > 
    > 价值 ：`INTEGER`
    > 
    > 8zJd5X6VqbTQNJ27QJ3cW5aCJy5UqKAcrPUe6HfBi1C3
    > 
    > 2048
    > 
    > 3C1iBfH6eUPrcAKqU5yJCc5Wc3JQ72JNQTbqV6X5dJz8
    > 
    > 1024
    > 
    > 现在，让我们考虑一下，哪种电路最适合证明这种微不足道的数据结构？
    > 
    > 最有可能的是，它将成为该类型的范围证明（正式定义示例：[https](https://hackmd.io/@dabo/B1U4kx8XI) ://hackmd.io/@dabo/B1U4kx8XI ）`INTEGER`和该类型的 plookup 增强位向量证明`STRING` 。所有的证明都将数据库的数据作为私有输入。最可能。
    
    但！如何证明特定查询结果不仅属于在 DBMS 中正确解压的特定数据库状态，而且还证明数据库（例如 Solana 的）状态本身是从正确的提交日志中解压的（例如属于实际的 Solana 的 so-称为“块序列”）？
    
    但是请注意，证明上述内容需要对证明进行额外的输入，即……
    

## 国家证明！

是的！正是我们与 [Solana](https://twitter.com/nil_foundation/status/1450789422996283394?s=21&t=U0yDZwY-oT9TGJ8KPNwuHQ) 和[Mina](https://twitter.com/minaprotocol/status/1443599014797135872?s=21)研究员为我们的[Solana 到以太坊](https://blog.nil.foundation/2021/10/14/solana-ethereum-bridge.html) 和[Mina 到以太坊](https://blog.nil.foundation/2021/09/30/mina-ethereum-bridge.html) 桥接项目开发的那些。

而且，对于那些没有自己的状态证明的集群，将使用类似 Solana 的方法。那些拥有自己的状态证明的集群（例如 Mina、Celo 等），它们将享受几乎开箱即用的查询证明。

现在它在更大的画面中聚集在一起了吗？

## 是的，但这些只是桥梁，而你在谈论完全不同的东西。这一切有什么关系？

很简单。结合 =nil; 陈述证明；'DROP DATABASE *的查询证明可以导致不同类型的应用程序。这完全取决于一个人如何应用它们。

本质上，一直以来，我们的桥梁项目只是测试第三方集群集成到我们协议中的极端情况的实验。

现在让我们考虑一些可以使用我们的协议构建的应用程序。我们将通过一个**令人难以置信的创新**工具展示这些用例——我们认为该工具代表**了博客的未来**——以及我们以前从未使用过的东西：**图片**。

## 无信任数据检索

可以在我们的协议之上构建的第一个用例是我们之前概述的：无信任数据检索。我们的协议如何促进这一点？

1.  用户（例如，应用程序前端）来到我们的协议中寻找一些数据。
2.  他们查询到=nil; 'DROP DATABASE * -基于数据库集群。
3.  该协议检索数据以及证明。此证明保证数据从数据库状态中正确检索，并且数据从目标数据库集群的提交日志中正确解压缩。

您现在可能想知道我们如何防止 DBMS 节点给出虚假证明。简单的。由于集群的所有节点都是=nil；'DROP DATABASE * 节点（可以立即访问所有外部可公开复制的数据库数据）协议将要求在将数据发送给用户之前由其余集群成员发布和验证证明。

这意味着必须激励查询证明生成节点向用户提供证明和数据。这意味着仅当所有 I/O 协议扩展集群参与者发布并验证有效查询证明时，才必须对特定查询的奖励进行评分。

## 现在我们开始。通过相同的=nil;对各种协议数据进行无信任数据访问；'DROP DATABASE *查询语言。

![](https://blog.nil.foundation/assets/images/2022-02-20-dbms-replication-protocol/case1.png)

## 无信任桥接

现在让我们考虑这样一种情况，客户端不是应用程序前端、交换器或验证器（任何外部数据消费者），而是第三方协议。

比方说，我们有 Solana 的/Avalanche 的/任何其他整体式 L1 集群。让我们说，在这样的集群中有一个 =nil; 'DROP DATABASE * 节点与 Solana 的复制协议适配器。它的行为就像 Solana 的节点（一个功能齐全的节点），它像一个一样嘎嘎叫，像一个一样游泳。但它不完全是一个。

这样一个**特殊的节点**以适合 =nil;的方式提供 Solana 的数据。'DROP DATABASE * -based cluster 为了能够跟踪它，每次用户通过查询请求它时，都可以根据 Solana 的数据（特定时刻的）生成状态证明。

在状态/查询证明由 =nil 生成之后；'DROP DATABASE *基于集群，应该提交给客户端协议（例如Mina或Ethereum），在那里应该验证，允许用户使用第三方的集群数据。

## 开始了。通过相同的=nil对各种协议进行无信任的按需桥接；'DROP DATABASE *查询语言。

![](https://blog.nil.foundation/assets/images/2022-02-20-dbms-replication-protocol/case2.png)

## 可插拔缩放

现在我们继续讨论另一个由我们的协议启用的用例示例。

在前面的示例中，我们考虑了协议两侧的集群不同的情况（例如，Ethereum 和 Solana，Solana 和 Mina 等）。但是当两侧的集群是同一类型（例如，Avalanche 和 Avalanche）时会发生什么？

现在让我们说，在所选的 L1 集群（例如 Avalanche）中，再次有一只“披着羊皮的狼”——a =nil；'DROP DATABASE * 节点与 Avalanche 的复制协议适配器。从任何其他 Avalanche 节点的角度来看，这个节点的行为就像一个普通的 Avalanche 节点（一个功能齐全的节点）——它看起来像一个，游泳像一个，叫声像一个，但它不完全是一个。

和！同样，因为它以适合 =nil;的方式提供 Avalanche 的数据。'DROP DATABASE * -based cluster 为了能够跟踪它，可以生成状态并从其状态或集群提交日志中查询证明，这意味着可以部署多个绝对独立的 Avalanche 数据库集群，这将一无所知关于彼此。但！通过我们的 I/O 集群，他们可以生成彼此的状态/查询证明，并通过 I/O 集群以无信任的方式访问彼此的数据。

这意味着=零；'DROP DATABASE * 集群能够生成客户端 L1 应用程序特定部署的状态/查询证明，并将它们提交给主集群进行验证。这实际上意味着通过所谓的“有效性证明”将不同数量的数据压缩到主 Avalanche 集群，线性增加吞吐量（也称为水平缩放），具体取决于特定于应用程序的独立 Avalanche 部署的数量。这种方法可以应用于任何单一的 L1 协议（Solana、以太坊、任何其他协议）。

## 瞧！无需信任的可插拔扩展，绝对不需要更改客户端协议。

![](https://blog.nil.foundation/assets/images/2022-02-20-dbms-replication-protocol/case3.png)

## 是时候结束了。

这个故事的寓意是所描述的所有应用程序都使用相同且唯一的一种机制：协议状态查询证明（查询引擎证明）和协议提交日志的状态证明。由于基于 DBMS 的方法使用非常典型、非常常用的 DBMS 功能，因此只能构建它，例如：

1.  **复制协议适配器。**因此，只能访问第三方数据库的数据，而无需将其复制到 I/O 集群中。
    
2.  **查询计划器/引擎。**因此，只能证明对各种数据库状态的查询。并且可以通过I/O集群应用到Eth，Solana什么的。
    
3.  **状态分区。**无需在同一台机器中处理数 TB 的状态数据。这也可以通过 I/O 集群应用于 Eth、Solana 或其他任何东西。
    
4.  **独立部署**。无法处理负载？只需再启动并运行一个数据库集群，就可以开始了。不需要“分片”之类的。
    
    > 是的，我完全清楚为什么存在分片——需要保持唯一一个数据库索引的一致性，这个数据库索引在这个行业的每个协议的数据库中都很重要——账户价值索引。我们将在以后的博文中讨论如何消除这种需求（是的，有这种方法）。敬请关注！
    > 
    > 顺便说一下，所有数据库目的都减少到唯一的一件事——维护唯一的键值索引，这很荒谬。所有其他数据都可以并且将会被删除[https://vitalik.ca/general/2021/12/06/endgame.html](https://vitalik.ca/general/2021/12/06/endgame.html) 并且每个人都可以接受。
    > 
    > 我什至被问到类似“除了帐户价值数据之外，你还想在数据库中存储什么（我们正在谈论的是以太坊）？这不是数据库，你想要什么？”
    > 
    > 从那以后我再也没有和那个家伙说过话。不要让你的孩子像那个家伙一样。
    
    你猜怎么着？这也可以通过 I/O 集群应用于 Eth、Solana 或其他任何东西。
    
5.  **适当的数据管理内部结构**。一些**无聊的老人**（他们最初获得学位而不是写关于比特币的博客）说，特定于 OLAP 和特定于 OLTP 的数据库负载类型需要不同的存储内部结构，而不是简单地使用 RocksDB 来处理所有事情。

## 让我们以一种无需信任的方式向每个人提供每个人的数据，好吗？